from __future__ import print_function

import http
import json
import pandas as pd
import copy

import statsmodels.stats.multitest as sms
from scipy.stats import binom, chi2_contingency
from flask_restplus import Namespace, Resource

from datetime import datetime, timedelta
from threading import Timer

from pymongo import MongoClient

from .downloadLineagesInfo import dict_lineage_mutation

api = Namespace('analyze', description='analyze')

uri = "mongodb://localhost:23456/gcm_gisaid"
client = MongoClient(uri)
db = client.gcm_gisaid

########################################################################################################


sars_cov_2_products = {
    "A": [
        {
            "name": "E (envelope protein)",
            "start": 26245,
            "end": 26472,
            "row": 0,
            "color": "#7c98b3",
            "sequence": "MYSFVSEETGTLIVNSVLLFLAFVVFLLVTLAILTALRLCAYCCNIVNVSLVKPSFYVYSRVKNLNSSRVPDLLV"
        },
        {
            "name": "M (membrane glycoprotein)",
            "start": 26523,
            "end": 27191,
            "row": 0,
            "color": "#536b78",
            "sequence": "MADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIKLIFLWLLWPVTLACFVLAAVYRINWITGGIAIAMACLVGLMWLSYFIASFRLFARTRSMWSFNPETNILLNVPLHGTILTRPLLESELVIGAVILRGHLRIAGHHLGRCDIKDLPKEITVATSRTLSYYKLGASQRVAGDSGFAAYSRYRIGNYKLNTDHSSSSDNIALLVQ"
        },
        {
            "name": "N (nucleocapsid phosphoprotein)",
            "start": 28274,
            "end": 29533,
            "row": 0,
            "color": "#f68e5f",
            "sequence": "MSDNGPQNQRNAPRITFGGPSDSTGSNQNGERSGARSKQRRPQGLPNNTASWFTALTQHGKEDLKFPRGQGVPINTNSSPDDQIGYYRRATRRIRGGDGKMKDLSPRWYFYYLGTGPEAGLPYGANKDGIIWVATEGALNTPKDHIGTRNPANNAAIVLQLPQGTTLPKGFYAEGSRGGSQASSRSSSRSRNSSRNSTPGSSRGTSPARMAGNGGDAALALLLLDRLNQLESKMSGKGQQQQGQTVTKKSAAEASKKPRQKRTATKAYNVTQAFGRRGPEQTQGNFGDQELIRQGTDYKHWPQIAQFAPSASAFFGMSRIGMEVTPSGTWLTYTGAIKLDDKDPNFKDQVILLNKHIDAYKTFPPTEPKKDKKKKADETQALPQRQKKQQTVTLLPAADLDDFSKQLQQSMSSADSTQA"
        },
        {
            "name": "ORF10 protein",
            "start": 29558,
            "end": 29674,
            "row": 0,
            "color": "#f76c5e",
            "sequence": "MGYINVFAFPFTIYSLLLCRMNSRNYIAQVDVVNFNLT"
        },
        {
            "name": "NSP16 (2'-O-ribose methyltransferase)",
            "start": 20659,
            "end": 21552,
            "row": 0,
            "color": "#22577a",
            "sequence": "SSQAWQPGVAMPNLYKMQRMLLEKCDLQNYGDSATLPKGIMMNVAKYTQLCQYLNTLTLAVPYNMRVIHFGAGSDKGVAPGTAVLRQWLPTGTLLVDSDLNDFVSDADSTLIGDCATVHTANKWDLIISDMYDPKTKNVTKENDSKEGFFTYICGFIQQKLALGGSVAIKITEHSWNADLYKLMGHFAWWTAFVTNVNASSSEAFLIGCNYLGKPREQIDGYVMHANYIFWRNTNPIQLSSYSLFDMSKFPLKLRGTAVMSLKEGQINDMILSLLSKGRLIIRENNRVVISSDVLVNN"
        },
        {
            "name": "NSP3",
            "start": 2720,
            "end": 8554,
            "row": 0,
            "color": "#7209b7",
            "sequence": "APTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGG"
        },
        {
            "name": "NSP4",
            "start": 8555,
            "end": 10054,
            "row": 0,
            "color": "#560bad",
            "sequence": "KIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQ"
        },
        {
            "name": "NSP15 (endoRNAse)",
            "start": 19621,
            "end": 20658,
            "row": 0,
            "color": "#38a3a5",
            "sequence": "SLENVAFNVVNKGHFDGQQGEVPVSIINNTVYTKVDGVDVELFENKTTLPVNVAFELWAKRNIKPVPEVKILNNLGVDIAANTVIWDYKRDAPAHISTIGVCSMTDIAKKPTETICAPLTVFFDGRVDGQVDLFRNARNGVLITEGSVKGLQPSVGPKQASLNGVTLIGEAVKTQFNYYKKVDGVVQQLPETYFTQSRNLQEFKPRSQMEIDFLELAMDEFIERYKLEGYAFEHIVYGDFSHSQLGGLHLLIGLAKRFKESPFELEDFIPMDSTVKNYFITDAQTGSSKCVCSVIDLLLDDFVEIIKSQDLSVVSKVVKVTIDYTEISFMLWCKDGHVETFYPKLQ"
        },
        {
            "name": "NSP5 (3C-like proteinase)",
            "start": 10055,
            "end": 10972,
            "row": 0,
            "color": "#480ca8",
            "sequence": "SGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQ"
        },
        {
            "name": "NSP14 (3'-to-5' exonuclease)",
            "start": 18040,
            "end": 19620,
            "row": 0,
            "color": "#57cc99",
            "sequence": "AENVTGLFKDCSKVITGLHPTQAPTHLSVDTKFKTEGLCVDIPGIPKDMTYRRLISMMGFKMNYQVNGYPNMFITREEAIRHVRAWIGFDVEGCHATREAVGTNLPLQLGFSTGVNLVAVPTGYVDTPNNTDFSRVSAKPPPGDQFKHLIPLMYKGLPWNVVRIKIVQMLSDTLKNLSDRVVFVLWAHGFELTSMKYFVKIGPERTCCLCDRRATCFSTASDTYACWHHSIGFDYVYNPFMIDVQQWGFTGNLQSNHDLYCQVHGNAHVASCDAIMTRCLAVHECFVKRVDWTIEYPIIGDELKINAACRKVQHMVVKAALLADKFPVLHDIGNPKAIKCVPQADVEWKFYDAQPCSDKAYKIEELFYSYATHSDKFTDGVCLFWNCNVDRYPANSIVCRFDTRVLSNLNLPGCDGGSLYVNKHAFHTPAFDKSAFVNLKQLPFFYYSDSPCESHGKQVVSDIDYVPLKSATCITRCNLGGAVCRHHANEYRLYLDAYNMMISAGFSLWVYKQFDTYNLWNTFTRLQ"
        },
        {
            "name": "NSP11",
            "start": 13442,
            "end": 13480,
            "row": 0,
            "color": "#65bc6e",
            "sequence": "SADAQSFLNGFAV"
        },
        {
            "name": "NSP13 (helicase)",
            "start": 16237,
            "end": 18039,
            "row": 0,
            "color": "#80ed99",
            "sequence": "AVGACVLCNSQTSLRCGACIRRPFLCCKCCYDHVISTSHKLVLSVNPYVCNAPGCDVTDVTQLYLGGMSYYCKSHKPPISFPLCANGQVFGLYKNTCVGSDNVTDFNAIATCDWTNAGDYILANTCTERLKLFAAETLKATEETFKLSYGIATVREVLSDRELHLSWEVGKPRPPLNRNYVFTGYRVTKNSKVQIGEYTFEKGDYGDAVVYRGTTTYKLNVGDYFVLTSHTVMPLSAPTLVPQEHYVRITGLYPTLNISDEFSSNVANYQKVGMQKYSTLQGPPGTGKSHFAIGLALYYPSARIVYTACSHAAVDALCEKALKYLPIDKCSRIIPARARVECFDKFKVNSTLEQYVFCTVNALPETTADIVVFDEISMATNYDLSVVNARLRAKHYVYIGDPAQLPAPRTLLTKGTLEPEYFNSVCRLMKTIGPDMFLGTCRRCPAEIVDTVSALVYDNKLKAHKDKSAQCFKMFYKGVITHDVSSAINRPQIGVVREFLTRNPAWRKAVFISPYNSQNAVASKILGLPTQTVDSSQGSEYDYVIFTQTTETAHSCNVNRFNVAITRAKVGILCIMSDRDLYDKLQFTSLEIPRRNVATLQ"
        },
        {
            "name": "NSP6",
            "start": 10973,
            "end": 11842,
            "row": 0,
            "color": "#3a0ca3",
            "sequence": "SAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQ"
        },
        {
            "name": "NSP7",
            "start": 11843,
            "end": 12091,
            "row": 0,
            "color": "#3f37c9",
            "sequence": "SKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQ"
        },
        {
            "name": "NSP8",
            "start": 12092,
            "end": 12685,
            "row": 0,
            "color": "#4361ee",
            "sequence": "AIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQ"
        },
        {
            "name": "NSP9",
            "start": 12686,
            "end": 13024,
            "row": 0,
            "color": "#4895ef",
            "sequence": "NNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQ"
        },
        {
            "name": "NSP12 (RNA-dependent RNA polymerase)",
            "start": 13442,
            "end": 16236,
            "row": 0,
            "color": "#c7f9cc",
            "sequence": "SADAQSFLNRVCGVSAARLTPCGTGTSTDVVYRAFDIYNDKVAGFAKFLKTNCCRFQEKDEDDNLIDSYFVVKRHTFSNYQHEETIYNLLKDCPAVAKHDFFKFRIDGDMVPHISRQRLTKYTMADLVYALRHFDEGNCDTLKEILVTYNCCDDDYFNKKDWYDFVENPDILRVYANLGERVRQALLKTVQFCDAMRNAGIVGVLTLDNQDLNGNWYDFGDFIQTTPGSGVPVVDSYYSLLMPILTLTRALTAESHVDTDLTKPYIKWDLLKYDFTEERLKLFDRYFKYWDQTYHPNCVNCLDDRCILHCANFNVLFSTVFPPTSFGPLVRKIFVDGVPFVVSTGYHFRELGVVHNQDVNLHSSRLSFKELLVYAADPAMHAASGNLLLDKRTTCFSVAALTNNVAFQTVKPGNFNKDFYDFAVSKGFFKEGSSVELKHFFFAQDGNAAISDYDYYRYNLPTMCDIRQLLFVVEVVDKYFDCYDGGCINANQVIVNNLDKSAGFPFNKWGKARLYYDSMSYEDQDALFAYTKRNVIPTITQMNLKYAISAKNRARTVAGVSICSTMTNRQFHQKLLKSIAATRGATVVIGTSKFYGGWHNMLKTVYSDVENPHLMGWDYPKCDRAMPNMLRIMASLVLARKHTTCCSLSHRFYRLANECAQVLSEMVMCGGSLYVKPGGTSSGDATTAYANSVFNICQAVTANVNALLSTDGNKIADKYVRNLQHRLYECLYRNRDVDTDFVNEFYAYLRKHFSMMILSDDAVVCFNSTYASQGLVASIKNFKSVLYYQNNVFMSEAKCWTETDLTKGPHEFCSQHTMLVKQGDDYVYLPYPDPSRILGAGCFVDDIVKTDGTLMIERFVSLAIDAYPLTKHPNQEYADVFHLYLQYIRKLHDELTGHMLDMYSVMLTNDNTSRYWEPEFYEAMYTPHTVLQ"
        },
        {
            "name": "ORF1ab polyprotein",
            "start": 266,
            "end": 21555,
            "row": 0,
            "color": "#89c4be",
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGGAYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGGAPTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGGKIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQSGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQSAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQSKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQAIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQNNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQAGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQSADAQSFLNRVCGVSAARLTPCGTGTSTDVVYRAFDIYNDKVAGFAKFLKTNCCRFQEKDEDDNLIDSYFVVKRHTFSNYQHEETIYNLLKDCPAVAKHDFFKFRIDGDMVPHISRQRLTKYTMADLVYALRHFDEGNCDTLKEILVTYNCCDDDYFNKKDWYDFVENPDILRVYANLGERVRQALLKTVQFCDAMRNAGIVGVLTLDNQDLNGNWYDFGDFIQTTPGSGVPVVDSYYSLLMPILTLTRALTAESHVDTDLTKPYIKWDLLKYDFTEERLKLFDRYFKYWDQTYHPNCVNCLDDRCILHCANFNVLFSTVFPPTSFGPLVRKIFVDGVPFVVSTGYHFRELGVVHNQDVNLHSSRLSFKELLVYAADPAMHAASGNLLLDKRTTCFSVAALTNNVAFQTVKPGNFNKDFYDFAVSKGFFKEGSSVELKHFFFAQDGNAAISDYDYYRYNLPTMCDIRQLLFVVEVVDKYFDCYDGGCINANQVIVNNLDKSAGFPFNKWGKARLYYDSMSYEDQDALFAYTKRNVIPTITQMNLKYAISAKNRARTVAGVSICSTMTNRQFHQKLLKSIAATRGATVVIGTSKFYGGWHNMLKTVYSDVENPHLMGWDYPKCDRAMPNMLRIMASLVLARKHTTCCSLSHRFYRLANECAQVLSEMVMCGGSLYVKPGGTSSGDATTAYANSVFNICQAVTANVNALLSTDGNKIADKYVRNLQHRLYECLYRNRDVDTDFVNEFYAYLRKHFSMMILSDDAVVCFNSTYASQGLVASIKNFKSVLYYQNNVFMSEAKCWTETDLTKGPHEFCSQHTMLVKQGDDYVYLPYPDPSRILGAGCFVDDIVKTDGTLMIERFVSLAIDAYPLTKHPNQEYADVFHLYLQYIRKLHDELTGHMLDMYSVMLTNDNTSRYWEPEFYEAMYTPHTVLQAVGACVLCNSQTSLRCGACIRRPFLCCKCCYDHVISTSHKLVLSVNPYVCNAPGCDVTDVTQLYLGGMSYYCKSHKPPISFPLCANGQVFGLYKNTCVGSDNVTDFNAIATCDWTNAGDYILANTCTERLKLFAAETLKATEETFKLSYGIATVREVLSDRELHLSWEVGKPRPPLNRNYVFTGYRVTKNSKVQIGEYTFEKGDYGDAVVYRGTTTYKLNVGDYFVLTSHTVMPLSAPTLVPQEHYVRITGLYPTLNISDEFSSNVANYQKVGMQKYSTLQGPPGTGKSHFAIGLALYYPSARIVYTACSHAAVDALCEKALKYLPIDKCSRIIPARARVECFDKFKVNSTLEQYVFCTVNALPETTADIVVFDEISMATNYDLSVVNARLRAKHYVYIGDPAQLPAPRTLLTKGTLEPEYFNSVCRLMKTIGPDMFLGTCRRCPAEIVDTVSALVYDNKLKAHKDKSAQCFKMFYKGVITHDVSSAINRPQIGVVREFLTRNPAWRKAVFISPYNSQNAVASKILGLPTQTVDSSQGSEYDYVIFTQTTETAHSCNVNRFNVAITRAKVGILCIMSDRDLYDKLQFTSLEIPRRNVATLQAENVTGLFKDCSKVITGLHPTQAPTHLSVDTKFKTEGLCVDIPGIPKDMTYRRLISMMGFKMNYQVNGYPNMFITREEAIRHVRAWIGFDVEGCHATREAVGTNLPLQLGFSTGVNLVAVPTGYVDTPNNTDFSRVSAKPPPGDQFKHLIPLMYKGLPWNVVRIKIVQMLSDTLKNLSDRVVFVLWAHGFELTSMKYFVKIGPERTCCLCDRRATCFSTASDTYACWHHSIGFDYVYNPFMIDVQQWGFTGNLQSNHDLYCQVHGNAHVASCDAIMTRCLAVHECFVKRVDWTIEYPIIGDELKINAACRKVQHMVVKAALLADKFPVLHDIGNPKAIKCVPQADVEWKFYDAQPCSDKAYKIEELFYSYATHSDKFTDGVCLFWNCNVDRYPANSIVCRFDTRVLSNLNLPGCDGGSLYVNKHAFHTPAFDKSAFVNLKQLPFFYYSDSPCESHGKQVVSDIDYVPLKSATCITRCNLGGAVCRHHANEYRLYLDAYNMMISAGFSLWVYKQFDTYNLWNTFTRLQSLENVAFNVVNKGHFDGQQGEVPVSIINNTVYTKVDGVDVELFENKTTLPVNVAFELWAKRNIKPVPEVKILNNLGVDIAANTVIWDYKRDAPAHISTIGVCSMTDIAKKPTETICAPLTVFFDGRVDGQVDLFRNARNGVLITEGSVKGLQPSVGPKQASLNGVTLIGEAVKTQFNYYKKVDGVVQQLPETYFTQSRNLQEFKPRSQMEIDFLELAMDEFIERYKLEGYAFEHIVYGDFSHSQLGGLHLLIGLAKRFKESPFELEDFIPMDSTVKNYFITDAQTGSSKCVCSVIDLLLDDFVEIIKSQDLSVVSKVVKVTIDYTEISFMLWCKDGHVETFYPKLQSSQAWQPGVAMPNLYKMQRMLLEKCDLQNYGDSATLPKGIMMNVAKYTQLCQYLNTLTLAVPYNMRVIHFGAGSDKGVAPGTAVLRQWLPTGTLLVDSDLNDFVSDADSTLIGDCATVHTANKWDLIISDMYDPKTKNVTKENDSKEGFFTYICGFIQQKLALGGSVAIKITEHSWNADLYKLMGHFAWWTAFVTNVNASSSEAFLIGCNYLGKPREQIDGYVMHANYIFWRNTNPIQLSSYSLFDMSKFPLKLRGTAVMSLKEGQINDMILSLLSKGRLIIRENNRVVISSDVLVNN"
        },
        {
            "name": "NSP10",
            "start": 13025,
            "end": 13441,
            "row": 0,
            "color": "#4cc9f0",
            "sequence": "AGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQ"
        },
        {
            "name": "NSP1 (leader protein)",
            "start": 266,
            "end": 805,
            "row": 0,
            "color": "#f72585",
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGG"
        },
        {
            "name": "ORF1a polyprotein",
            "start": 266,
            "end": 13483,
            "row": 0,
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGGAYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGGAPTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGGKIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQSGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQSAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQSKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQAIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQNNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQAGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQSADAQSFLNGFAV"
        },
        {
            "name": "NSP2",
            "start": 806,
            "end": 2719,
            "row": 0,
            "color": "#ccb7ae",
            "sequence": "AYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGG"
        },
        {
            "name": "NS3 (ORF3a protein)",
            "start": 25393,
            "end": 26220,
            "row": 0,
            "color": "#a3a3a3",
            "sequence": "MDLFMRIFTIGTVTLKQGEIKDATPSDFVRATATIPIQASLPFGWLIVGVALLAVFQSASKIITLKKRWQLALSKGVHFVCNLLLLFVTVYSHLLLVAAGLEAPFLYLYALVYFLQSINFVRIIMRLWLCWKCRSKNPLLYDANYFLCWHTNCYDYCIPYNSVTSSIVITSGDGTTSPISEHDYQIGGYTEKWESGVKDCVVLHSYFTSDYYQLYSTQLSTDTGVEHVTFFIYNKIVDEPEEHVQIHTIDGSSGVVNPVMEPIYDEPTTTTSVPL"
        },
        {
            "name": "NS6 (ORF6 protein)",
            "start": 27202,
            "end": 27387,
            "row": 0,
            "color": "#586ba4",
            "sequence": "MFHLVDFQVTIAEILLIIMRTFKVSIWNLDYIINLIIKNLSKSLTENKYSQLDEEQPMEID"
        },
        {
            "name": "NS7a (ORF7a protein)",
            "start": 27394,
            "end": 27759,
            "row": 0,
            "color": "#324376",
            "sequence": "MKIILFLALITLATCELYHYQECVRGTTVLLKEPCSSGTYEGNSPFHPLADNKFALTCFSTQFAFACPDGVKHVYQLRARSVSPKLFIRQEEVQELYSPIFLIVAAIVFITLCFTLKRKTE"
        },
        {
            "name": "NS7b (ORF7b)",
            "start": 27756,
            "end": 27887,
            "row": 0,
            "color": "#f5dd90",
            "sequence": "MIELSLIDFYLCFLAFLLFLVLIMLIIFWFSLELQDHNETCHA"
        },
        {
            "name": "NS8 (ORF8 protein)",
            "start": 27894,
            "end": 28259,
            "row": 0,
            "color": "#b79738",
            "sequence": "MKFLVFLGIITTVAAFHQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEAGSKSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI"
        },
        {
            "name": "Spike (surface glycoprotein)",
            "start": 21563,
            "end": 25384,
            "row": 0,
            "color": "#accbe1",
            "sequence": "MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDKVEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT"
        }
    ],
    "N": [
        {
            "name": "ORF10",
            "start": 29558,
            "end": 29674,
            "row": 0
        },
        {
            "name": "ORF1ab",
            "start": 266,
            "end": 21555,
            "row": 0
        },
        {
            "name": "ORF3a",
            "start": 25393,
            "end": 26220,
            "row": 0
        },
        {
            "name": "ORF6",
            "start": 27202,
            "end": 27387,
            "row": 0
        },
        {
            "name": "ORF7a",
            "start": 27394,
            "end": 27759,
            "row": 0
        },
        {
            "name": "ORF7b",
            "start": 27756,
            "end": 27887,
            "row": 0
        },
        {
            "name": "ORF8",
            "start": 27894,
            "end": 28259,
            "row": 0
        }
    ]
}


########################################################################################################


@api.route('/allGeo')
class FieldList(Resource):
    @api.doc('all_geo')
    def get(self):
        all_geo = all_geo_dict['all_geo']
        return all_geo


@api.route('/allProtein')
class FieldList(Resource):
    @api.doc('all_protein')
    def get(self):
        all_protein = all_protein_dict['all_protein']
        return all_protein


@api.route('/tableLineageCountry')
class FieldList(Resource):
    @api.doc('table_lineage_country')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/tableLineageCountry', json_data, headers)

        response = conn.getresponse()
        all_geo = response.read().decode()
        all_geo = json.loads(all_geo)

        table = []
        for item in all_geo:
            single_line = {'lineage': item['lineage']}
            country_count = item['country_count']
            country_count = country_count.replace('"', "")
            country_count = country_count.replace("\\", "")
            country_count = country_count.replace("{", "")
            country_count = country_count.replace("}", "")
            country_count = country_count.replace("(", "")
            array_country_count = country_count.split("),")
            for single_country in array_country_count:
                single_country = single_country.replace(")", "")
                array_single_country = single_country.split(',')
                single_line[array_single_country[0]] = array_single_country[1]
            table.append(single_line)

        return table


@api.route('/possibleCountryLineage')
class FieldList(Resource):
    @api.doc('possible_country_lineage')
    def post(self):
        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/arrayCountryForLineage', json_data, headers)

        response = conn.getresponse()
        all_country = response.read().decode()
        all_country = all_country.replace(']', '').replace('[', '')
        all_country = all_country.replace('"', '').split(",")

        return all_country


@api.route('/denominatorLineageCountry')
class FieldList(Resource):
    @api.doc('possible_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/denominatorLineageCountry', json_data, headers)

        response = conn.getresponse()
        resp = response.read().decode()
        resp = json.loads(resp)

        denominators = {}

        for item in resp:
            if item['geo'] is None:
                denominators['N/D'] = item['cnt']
            else:
                denominators[item['geo']] = item['cnt']

        return denominators


@api.route('/analyzeMutationCountryLineage')
class FieldList(Resource):
    @api.doc('analyze_mutation_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationCountryLineage', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        arr_p_values = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['country']
            single_item['background'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_country']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_country']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                # single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_country'],
                #                                        item['numerator'] / item['denominator'])
                stat, p, dof, expected =  \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p
            else:
                # single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_country'],
                #                                    item['numerator'] / item['denominator'])
                stat, p, dof, expected = \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p

            arr_p_values.append(single_item['p_value'])
            mutation_table2.append(single_item)

        a, new_p_values, c, d = sms.multipletests(arr_p_values, method='bonferroni')

        i = 0
        for item in mutation_table2:
            item['pvalue'] = new_p_values[i]
            i = i + 1

        return mutation_table2


@api.route('/analyzeMutationCountryLineageInTime')
class FieldList(Resource):
    @api.doc('analyze_mutation_country_lineage_in_time')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationCountryLineageInTime', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        arr_p_values = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['target_time']
            single_item['background'] = item['background_time']
            single_item['country'] = item['country']
            single_item['lineage'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                # single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                #                                        item['numerator'] / item['denominator'])
                stat, p, dof, expected =  \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p
            else:
                # single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                #                                    item['numerator'] / item['denominator'])
                stat, p, dof, expected = \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p

            arr_p_values.append(single_item['p_value'])
            mutation_table2.append(single_item)

        a, new_p_values, c, d = sms.multipletests(arr_p_values, method='bonferroni')

        i = 0
        for item in mutation_table2:
            item['pvalue'] = new_p_values[i]
            i = i + 1

        return mutation_table2


@api.route('/analyzeTimeDistributionCountryLineage')
class FieldList(Resource):
    @api.doc('analyze_time_distribution_country_lineage')
    def post(self):
        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeTimeDistributionCountryLineage', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/analyzeTimeDistributionBackgroundQueryGeo')
class FieldList(Resource):
    @api.doc('analyze_time_distribution_country_lineage')
    def post(self):
        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeTimeDistributionBackgroundQueryGeo', json_data,
                     headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/analyzeMutationProvinceRegion')
class FieldList(Resource):
    @api.doc('analyze_mutation_province_region')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationProvinceRegion', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        arr_p_values = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            # if 'country' in item:
            #    single_item['target'] = item['region']
            #    single_item['background'] = item['country']
            # else:
            #    single_item['target'] = item['province']
            #    single_item['background'] = item['region']
            single_item['target'] = item['target']
            single_item['background'] = item['background']

            single_item['lineage'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                # single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                #                                        item['numerator'] / item['denominator'])
                stat, p, dof, expected = \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p
            else:
                # single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                #                                    item['numerator'] / item['denominator'])
                stat, p, dof, expected = \
                    chi2_contingency([[single_item['numerator_background'],
                                       single_item['denominator_background'] - single_item['numerator_background']],
                                      [single_item['numerator_target'],
                                       single_item['denominator_target'] - single_item['numerator_target']]])
                single_item['p_value'] = p

            arr_p_values.append(single_item['p_value'])
            mutation_table2.append(single_item)

        a, new_p_values, c, d = sms.multipletests(arr_p_values, method='bonferroni')

        i = 0
        for item in mutation_table2:
            item['pvalue'] = new_p_values[i]
            i = i + 1

        return mutation_table2


@api.route('/analyzeMutationTargetBackgroundFree')
class FieldList(Resource):
    @api.doc('analyze_mutation_target_background_free')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationTargetBackgroundFree', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        arr_p_values = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['target']
            single_item['background'] = item['background']

            single_item['lineage'] = item['lineage']
            single_item['lineage_target'] = item['lineage_target']
            single_item['lineage_background'] = item['lineage_background']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                if item['denominator'] != 0:
                    # single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                    #                                        item['numerator'] / item['denominator'])
                    stat, p, dof, expected = \
                        chi2_contingency([[single_item['numerator_background'],
                                           single_item['denominator_background'] - single_item['numerator_background']],
                                          [single_item['numerator_target'],
                                           single_item['denominator_target'] - single_item['numerator_target']]])
                    single_item['p_value'] = p
                else:
                    # single_item['p_value'] = 0
                    stat, p, dof, expected = \
                        chi2_contingency([[single_item['numerator_background'],
                                           single_item['denominator_background'] - single_item['numerator_background']],
                                          [single_item['numerator_target'],
                                           single_item['denominator_target'] - single_item['numerator_target']]])
                    single_item['p_value'] = p
            else:
                if item['denominator'] != 0:
                    # single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                    #                                    item['numerator'] / item['denominator'])
                    stat, p, dof, expected = \
                        chi2_contingency([[single_item['numerator_background'],
                                           single_item['denominator_background'] - single_item['numerator_background']],
                                          [single_item['numerator_target'],
                                           single_item['denominator_target'] - single_item['numerator_target']]])
                    single_item['p_value'] = p
                else:
                    # single_item['p_value'] = 0
                    stat, p, dof, expected = \
                        chi2_contingency([[single_item['numerator_background'],
                                           single_item['denominator_background'] - single_item['numerator_background']],
                                          [single_item['numerator_target'],
                                           single_item['denominator_target'] - single_item['numerator_target']]])
                    single_item['p_value'] = p

            arr_p_values.append(single_item['p_value'])
            mutation_table2.append(single_item)

        a, new_p_values, c, d = sms.multipletests(arr_p_values, method='bonferroni')

        i = 0
        for item in mutation_table2:
            item['pvalue'] = new_p_values[i]
            i = i + 1

        return mutation_table2


@api.route('/countOverlappingSequenceTargetBackground')
class FieldList(Resource):
    @api.doc('count_overlapping_sequence_target_background')
    def post(self):
        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/countOverlappingSequenceTargetBackground', json_data,
                     headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/selectorQuery')
class FieldList(Resource):
    @api.doc('selector_query')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/selectorQuery', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/getAccessionIds')
class FieldList(Resource):
    @api.doc('selector_query')
    def post(self):
        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/getAccessionIds', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/getProteinPosition')
class FieldList(Resource):
    @api.doc('get_protein_position')
    def post(self):

        payload = api.payload
        name_protein = payload['protein']

        all_protein = sars_cov_2_products['A']
        min_pos = 0
        max_pos = 0
        for item in all_protein:
            name = str(item.get('name'))
            if name.lower() == name_protein.lower():
                min_pos = 1
                max_pos = (item.get('end') - item.get('start')) // 3
                if "nsp" in name.lower():
                    max_pos = max_pos + 1

        res = {'start': min_pos, 'stop': max_pos}

        return res


@api.route('/getDomains')
class FieldList(Resource):
    @api.doc('get_domains')
    def post(self):
        payload = api.payload
        name_protein = payload['protein']

        annotations = pd.read_csv("apis/protein_annotations.csv",
                                  delimiter=',')

        annotations1 = copy.deepcopy(annotations)
        annotations2 = copy.deepcopy(annotations)
        annotations3 = copy.deepcopy(annotations)

        ann_mutagenesis = annotations1[(annotations.Description.str.lower() != 'n/d')
                                       & (annotations.Protein.str.lower() == name_protein.lower())
                                       & (annotations.Category.str.lower() == 'mutagenesis')
                                       ]
        ann_mutagenesis2 = ann_mutagenesis[['Description', 'Begin', 'End']]
        ann_mutagenesis3 = json.loads(ann_mutagenesis2.to_json(orient="records"))

        ann_aa_modifications = annotations2[(annotations.Description.str.lower() != 'n/d')
                                            & (annotations.Protein.str.lower() == name_protein.lower())
                                            & (annotations.Category.str.lower() == 'ptm')
                                            & (annotations.Type.str.lower() == 'carbohyd')
                                            ]
        ann_aa_modifications2 = ann_aa_modifications[['Description', 'Begin', 'End']]
        ann_aa_modifications3 = json.loads(ann_aa_modifications2.to_json(orient="records"))

        ann_sites_family_dom = annotations3[(annotations.Description.str.lower() != 'n/d')
                                            & (annotations.Protein.str.lower() == name_protein.lower())
                                            & ((annotations.Category.str.lower() == 'domains_and_sites') |
                                               (annotations.Type.str.lower() == 'n/d'))
                                            ]
        ann_sites_family_dom2 = ann_sites_family_dom[['Description', 'Begin', 'End']]
        ann_sites_family_dom3 = json.loads(ann_sites_family_dom2.to_json(orient="records"))

        result = {'mutagenesis': ann_mutagenesis3, 'aa_modifications': ann_aa_modifications3,
                  'sites_and_domains': ann_sites_family_dom3}

        return result


@api.route('/getImportantMutation')
class FieldList(Resource):
    @api.doc('get_important_mutation')
    def post(self):

        payload = api.payload
        name_lineage = payload['lineage']

        result = {'mutation': [], 'additional_mutation': []}

        if name_lineage in dict_lineage_mutation:
            lineage_json = dict_lineage_mutation[name_lineage]
            result['mutation'] = lineage_json['mutation']
            result['additional_mutation'] = lineage_json['additional_mutation']
        else:
            all_mutation = []
            all_additional_mutation = []
            for lineage in dict_lineage_mutation:
                row = dict_lineage_mutation[lineage]
                for mutation in row['mutation']:
                    if mutation not in all_mutation:
                        all_mutation.append(mutation)
                    if mutation in all_additional_mutation:
                        all_additional_mutation.remove(mutation)
                for additional_mutation in row['additional_mutation']:
                    if additional_mutation not in all_additional_mutation and additional_mutation not in all_mutation:
                        all_additional_mutation.append(additional_mutation)
            result['mutation'] = all_mutation
            result['additional_mutation'] = all_additional_mutation

        return result


@api.route('/getLineageTree')
class FieldList(Resource):
    @api.doc('get_lineage_tree')
    def post(self):

        payload = api.payload
        possible_lineages = payload['possibleLineages']

        dict_copy = dict_lineage_mutation

        arr_lineages = []
        dict_lineages = {}
        for item in possible_lineages:
            single_line = item
            dict_lineages[item['value']] = single_line
            arr_lineages.append(item['value'])

        dict_copy2 = dict(sorted(dict_copy.items(), key=lambda k_v: k_v[1]['alias']))

        items = []
        idx = 1

        for lineage in dict_copy2:
            already_done = False
            children = False
            children_lineage = False
            important_lineage = False
            alias = dict_copy2[lineage]['alias']
            if lineage in arr_lineages:
                if dict_copy2[lineage]['WHO label'] != '':
                    important_lineage = True
                for itm in items:
                    possible_parent_alias = str(itm['alias']) + '.'
                    possible_children_alias = str(alias)
                    possible_parent_lineage = str(itm['real_name']) + '.'
                    possible_children_lineage = str(lineage)
                    if possible_parent_alias in possible_children_alias:
                        children = True
                        recursive_children_lineage(itm, lineage, alias, dict_copy2, dict_lineages)
                    if possible_parent_lineage in possible_children_lineage:
                        children_lineage = True
                        if possible_children_lineage != possible_children_alias:
                            recursive_children_lineage(itm, lineage, lineage, dict_copy2, dict_lineages)
                if not children:
                    already_done = True
                    name_complete = lineage
                    if dict_copy2[lineage]['WHO label'] != '':
                        name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
                    single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage,
                                      'who': dict_copy2[lineage]['WHO label'], 'children': [],
                                      'count': dict_lineages[lineage]['count']}
                    items.append(single_lineage)
                    idx = idx + 1

                if not children_lineage and not already_done:
                    name_complete = lineage.split('.')[0]
                    single_lineage = {'id': idx, 'alias': name_complete, 'name': name_complete,
                                      'real_name': name_complete,
                                      'who': '', 'children': [],
                                      'count': 0}
                    items.append(single_lineage)
                    idx = idx + 1
                    recursive_children_lineage(single_lineage, lineage, lineage, dict_copy2, dict_lineages)

                # if important_lineage and not already_done:
                #     name_complete = lineage
                #     if dict_copy2[lineage]['WHO label'] != '':
                #         name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
                #     single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage,
                #                       'who': dict_copy2[lineage]['WHO label'], 'children': [],
                #                       'count': dict_lineages[lineage]['count']}
                #     items.append(single_lineage)
                #     idx = idx + 1

        return items


@api.route('/getAllImportantMutationPerLineage')
class FieldList(Resource):
    @api.doc('get_important_mutation')
    def post(self):

        payload = api.payload
        lineage = payload['lineage']
        proteins = payload['proteins']

        array_proteins = []

        for protein in proteins:
            protein_rewritten = protein.split(" ")[0]
            array_proteins.append(protein_rewritten)

        dict_copy = all_important_mutation_dict

        array_important_mutation = []

        if lineage is None:
            for lineage_mutations in dict_copy:
                single_lineage_mutation = dict_copy[lineage_mutations]
                for mutation in single_lineage_mutation['common_changes']:
                    if mutation not in array_important_mutation:
                        protein = mutation.split("_")[0]
                        if protein in array_proteins:
                            array_important_mutation.append(mutation)
                            array_important_mutation.sort()
        else:
            if lineage in dict_copy:
                single_lineage_mutation = dict_copy[lineage]
                for mutation in single_lineage_mutation['common_changes']:
                    if mutation not in array_important_mutation:
                        protein = mutation.split("_")[0]
                        if protein in array_proteins:
                            array_important_mutation.append(mutation)
                            array_important_mutation.sort()

        return array_important_mutation


@api.route('/checkAccessionId')
class FieldList(Resource):
    @api.doc('check_accession_id')
    def post(self):

        payload = api.payload
        accession_id = payload['accession_id']
        acc_id_arr = all_accession_id_dict['all_acc_id']
        result = False
        if accession_id in acc_id_arr:
            result = True
        return result


def recursive_children_lineage(parent, lineage, alias, dict_copy2, dict_lineages):
    children = False
    idx = str(parent['id']) + '_' + str(len(parent['children']))
    for itm in parent['children']:
        possible_parent_alias = str(itm['alias']) + '.'
        possible_children_alias = str(alias)
        if possible_parent_alias in possible_children_alias:
            children = True
            recursive_children_lineage(itm, lineage, alias, dict_copy2, dict_lineages)
            break
        else:
            children = False
    if not children:
        name_complete = lineage
        if dict_copy2[lineage]['WHO label'] != '':
            name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
        single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage,
                          'who': dict_copy2[lineage]['WHO label'],
                          'children': [], 'count': dict_lineages[lineage]['count']}
        parent['children'].append(single_lineage)


all_important_mutation_dict = {}


def get_all_important_mutation():
    print("inizio request important mutation")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allImportantMutations')

    response = conn.getresponse()
    all_important_mutation = response.read().decode()
    all_important_mutation = json.loads(all_important_mutation)

    for mutation_per_lineage in all_important_mutation:
        lineage = mutation_per_lineage['lineage']
        all_important_mutation_dict[lineage] = mutation_per_lineage
    print("fine request important mutation")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t1 = Timer(secs, get_all_important_mutation)
    t1.start()


all_protein_dict = {}


def get_all_protein():
    print("inizio request protein")
    to_send = {'gcm': {'taxon_name': ["severe acute respiratory syndrome coronavirus 2"]}}

    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    headers = {'Content-type': 'application/json'}
    send = to_send
    json_data = json.dumps(send)
    conn.request('POST', '/virusurf_epitope/api/epitope/allProtein', json_data, headers)

    response = conn.getresponse()
    all_protein = response.read().decode()
    all_protein = json.loads(all_protein)
    all_protein_dict['all_protein'] = all_protein
    print("fine request protein")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t2 = Timer(secs, get_all_protein)
    t2.start()


all_geo_dict = {}


def get_all_geo():
    print("inizio request geo")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allGeo')

    response = conn.getresponse()
    all_geo = response.read().decode()
    all_geo = json.loads(all_geo)
    all_geo_dict['all_geo'] = all_geo
    print("fine request geo")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t4 = Timer(secs, get_all_geo)
    t4.start()


all_accession_id_dict = {}


def get_all_accession_id():
    print("inizio request accession id")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allAccessionIds')

    response = conn.getresponse()
    all_acc_id = response.read().decode()
    all_acc_id = json.loads(all_acc_id)
    all_accession_id_arr = []
    for itm in all_acc_id:
        all_accession_id_arr.append(itm['accession_id'])
    all_accession_id_dict['all_acc_id'] = all_accession_id_arr
    print("fine request accession id")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t3 = Timer(secs, get_all_geo)
    t3.start()

# -----------------------------------------    MONGO DB    ----------------------------------------------- #


translate_dictionary = {
    'accession_id': '_id',
    'lineage': 'covv_lineage',
    'collection_date': 'covv_collection_date',
    'location': 'covv_location',
}


def prova_mongo_db():
    print("prova Mongo")
    seq = db.seq
    print("prova Mongo2")

    #             "$match": {
    #             # 'covv_collection_date': {
    #             #     '$gte': "2019-01-01",
    #             #     '$lte': "2021-07-31",
    #             #     '$regex': "\d\d\d\d-\d\d-\d\d"
    #             # },
    #             # 'covv_location': {
    #             #     '$regex': "Italy"
    #             #  },

    pipeline = [
        {
            "$match": {
                'location.geo_group': {
                    '$eq': 'Oceania'
                },
                'location.country': {
                    '$eq': 'Australia'
                },
                'location.region': {
                    '$eq': 'Northern Territory'
                },
            },
        },
        {"$unwind": "$muts"},
        {"$group":
         #{"_id": "$_id",
            {"_id":
                {'pro': "$muts.pro",
                 'org': "$muts.org",
                 'loc': "$muts.loc",
                 'alt': "$muts.alt",
                 },
             "count": {"$sum": 1}
             }
         },
        {'$sort':
            {"_id.pro": -1}
         }
    ]
    print("start")
    results = seq.aggregate(pipeline, )
    print("stop", len(list(results)))
    # for i, x in enumerate(results):
    #    print("qui", x)
    #    if i < 1:
    #        print("qui", x)
    #         break
    print("fine prova Mongo2")


def get_all_geo_mongoDB():
    print("inizio request geo")
    start_date = datetime.strptime("2019-01-01", '%Y-%m-%d')
    results = db.seq.aggregate(
        [
            {
                "$match": {
                    'collection_date': {
                        '$gte': start_date
                    },
                    'c_coll_date_prec': {
                        '$eq': 2
                      },
                },
            },
            {
                "$group": {"_id":
                               {"geo_group": "$location.geo_group",
                                "country": "$location.country",
                                "region": "$location.region",
                                "province": "$location.province"
                                },
                           "count": {"$sum": 1}
                           }
            },
        ]
    )
    list_geo_dict = []
    for single_item in results:
        single_item_remodel = {'geo_group': single_item['_id']['geo_group'],
                               'country': single_item['_id']['country'],
                               'region': single_item['_id']['region'],
                               'province': single_item['_id']['province'], 'count': single_item['count']}
        list_geo_dict.append(single_item_remodel)
    all_geo_dict['all_geo'] = list_geo_dict
    print("fine request geo")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t4 = Timer(secs, get_all_geo)
    t4.start()


@api.route('/selectorQueryMongoDB')
class FieldList(Resource):
    @api.doc('selector_query_mongo_db')
    def post(self):

        to_use = api.payload
        field_name = to_use['field']
        query_fields = to_use['query']

        # field_name = 'country'
        # query_fields = {'lineage': 'B.1', 'geo_group': ['Europe', 'Asia'], 'minDate': '2020-01-01', 'maxDate': "2021-01-01",
        #                 'toExclude': {}}
        # 'toExclude': {'geo_group': ['Asia'], 'country': ['Italy', 'France']

        if field_name in query_fields:
            del query_fields[field_name]

        i = 0
        where_part = {}
        start_date = datetime.strptime("2019-01-01", '%Y-%m-%d')
        where_part['c_coll_date_prec'] = {}
        where_part['c_coll_date_prec']['$eq'] = 2
        where_part['collection_date'] = {}
        where_part['collection_date']['$gte'] = start_date

        field_not_null = field_name
        if field_not_null in translate_dictionary:
            field_not_null = translate_dictionary[field_name]
        if field_name == 'geo_group' or field_name == 'country' or field_name == 'region' or field_name == 'province':
            field_not_null = 'location.' + field_name
        where_part[field_not_null] = {'$ne': None}

        if query_fields is not None:
            for key in query_fields:
                if key == 'minDate':
                    start_date = datetime.strptime(f"{query_fields[key]}", '%Y-%m-%d')
                    where_part['collection_date']['$gte'] = start_date
                elif key == 'maxDate':
                    stop_date = datetime.strptime(f"{query_fields[key]}", '%Y-%m-%d')
                    where_part['collection_date']['$lte'] = stop_date

                elif key == 'toExclude':
                    for fieldToExclude in query_fields[key]:
                        if '$and' not in where_part:
                            where_part['$and'] = []

                        single_where_part = {'$and': []}
                        for geoToExclude in query_fields[key][fieldToExclude]:
                            real_field_to_exclude = fieldToExclude
                            if fieldToExclude == 'geo_group' or fieldToExclude == 'country' \
                                    or fieldToExclude == 'region' or fieldToExclude == 'province':
                                real_field_to_exclude = 'location.' + fieldToExclude
                            specific_and = {}
                            geo_value = geoToExclude.replace("'", "''")
                            specific_and[f'{real_field_to_exclude}'] = {'$ne': geo_value}
                            single_where_part['$and'].append(specific_and)
                        where_part['$and'].append(single_where_part)

                elif key == 'geo_group' or key == 'country' or key == 'region' or key == 'province':
                    if '$and' not in where_part:
                        where_part['$and'] = []

                    real_key = key
                    if key == 'geo_group' or key == 'country' or key == 'region' or key == 'province':
                        real_key = 'location.' + key
                    if isinstance(query_fields[key], list):
                        single_where_part_or = {'$or': []}
                        for itm in query_fields[key]:
                            specific_or = {}
                            field_value = itm.replace("'", "''")
                            specific_or[f'{real_key}'] = {'$eq': field_value}
                            single_where_part_or['$or'].append(specific_or)
                        where_part['$and'].append(single_where_part_or)
                    else:
                        single_where_part_or = {'$or': []}
                        replace_fields_value = query_fields[key].replace("'", "''")
                        specific_or = {f'{real_key}': {'$eq': replace_fields_value}}
                        single_where_part_or['$or'].append(specific_or)
                        where_part['$and'].append(single_where_part_or)

                else:
                    real_key = key
                    if key in translate_dictionary:
                        real_key = translate_dictionary[key]
                    replace_fields_value = query_fields[key]
                    if key != 'start_aa_original':
                        replace_fields_value = query_fields[key].replace("'", "''")
                    if real_key not in where_part:
                        where_part[real_key] = {}
                    where_part[real_key]['$eq'] = replace_fields_value

                i = i + 1

        query = []

        query_where = {"$match": where_part}
        query.append(query_where)

        group_part = {}
        real_field = field_name
        if field_name in translate_dictionary:
            real_field = translate_dictionary[field_name]
        if field_name == 'geo_group' or field_name == 'country' or field_name == 'region' or field_name == 'province':
            real_field = 'location.' + field_name
        group_part["_id"] = {"value": f"${real_field}"}
        group_part["count"] = {"$sum": 1}
        query_group = {"$group": group_part}
        query.append(query_group)

        sort_part = {"count": -1}
        query_sort = {"$sort": sort_part}
        query.append(query_sort)
        # print("query", query)

        results = db.seq.aggregate(query)

        list_dict = []
        for single_item in list(results):
            single_item_remodel = {}
            for key in single_item:
                if key == '_id':
                    single_item_remodel['value'] = single_item['_id']['value']
                else:
                    single_item_remodel[key] = single_item[key]
            list_dict.append(single_item_remodel)

        # print("field:", field_name, "  result:", list_dict)
        return list_dict


def prova_mongo_2():
    print("qui2")

# -----------------------------------------    START FUNCTIONS    ----------------------------------------------- #


get_all_important_mutation()
get_all_accession_id()
get_all_geo()
get_all_protein()

# prova_mongo_db()
# prova_mongo_2()
