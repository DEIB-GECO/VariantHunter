from __future__ import print_function

import http
import json
import pandas as pd
import copy

from scipy.stats import binom
from flask_restplus import Namespace, Resource

from datetime import datetime, timedelta
from threading import Timer

from pymongo import MongoClient

from .downloadLineagesInfo import dict_lineage_mutation

api = Namespace('analyze', description='analyze')

uri = "mongodb://localhost:23456/gcm_gisaid"
client = MongoClient(uri)
db = client.gcm_gisaid

########################################################################################################


sars_cov_2_products = {
    "A": [
        {
            "name": "E (envelope protein)",
            "start": 26245,
            "end": 26472,
            "row": 0,
            "color": "#7c98b3",
            "sequence": "MYSFVSEETGTLIVNSVLLFLAFVVFLLVTLAILTALRLCAYCCNIVNVSLVKPSFYVYSRVKNLNSSRVPDLLV"
        },
        {
            "name": "M (membrane glycoprotein)",
            "start": 26523,
            "end": 27191,
            "row": 0,
            "color": "#536b78",
            "sequence": "MADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIKLIFLWLLWPVTLACFVLAAVYRINWITGGIAIAMACLVGLMWLSYFIASFRLFARTRSMWSFNPETNILLNVPLHGTILTRPLLESELVIGAVILRGHLRIAGHHLGRCDIKDLPKEITVATSRTLSYYKLGASQRVAGDSGFAAYSRYRIGNYKLNTDHSSSSDNIALLVQ"
        },
        {
            "name": "N (nucleocapsid phosphoprotein)",
            "start": 28274,
            "end": 29533,
            "row": 0,
            "color": "#f68e5f",
            "sequence": "MSDNGPQNQRNAPRITFGGPSDSTGSNQNGERSGARSKQRRPQGLPNNTASWFTALTQHGKEDLKFPRGQGVPINTNSSPDDQIGYYRRATRRIRGGDGKMKDLSPRWYFYYLGTGPEAGLPYGANKDGIIWVATEGALNTPKDHIGTRNPANNAAIVLQLPQGTTLPKGFYAEGSRGGSQASSRSSSRSRNSSRNSTPGSSRGTSPARMAGNGGDAALALLLLDRLNQLESKMSGKGQQQQGQTVTKKSAAEASKKPRQKRTATKAYNVTQAFGRRGPEQTQGNFGDQELIRQGTDYKHWPQIAQFAPSASAFFGMSRIGMEVTPSGTWLTYTGAIKLDDKDPNFKDQVILLNKHIDAYKTFPPTEPKKDKKKKADETQALPQRQKKQQTVTLLPAADLDDFSKQLQQSMSSADSTQA"
        },
        {
            "name": "ORF10 protein",
            "start": 29558,
            "end": 29674,
            "row": 0,
            "color": "#f76c5e",
            "sequence": "MGYINVFAFPFTIYSLLLCRMNSRNYIAQVDVVNFNLT"
        },
        {
            "name": "NSP16 (2'-O-ribose methyltransferase)",
            "start": 20659,
            "end": 21552,
            "row": 0,
            "color": "#22577a",
            "sequence": "SSQAWQPGVAMPNLYKMQRMLLEKCDLQNYGDSATLPKGIMMNVAKYTQLCQYLNTLTLAVPYNMRVIHFGAGSDKGVAPGTAVLRQWLPTGTLLVDSDLNDFVSDADSTLIGDCATVHTANKWDLIISDMYDPKTKNVTKENDSKEGFFTYICGFIQQKLALGGSVAIKITEHSWNADLYKLMGHFAWWTAFVTNVNASSSEAFLIGCNYLGKPREQIDGYVMHANYIFWRNTNPIQLSSYSLFDMSKFPLKLRGTAVMSLKEGQINDMILSLLSKGRLIIRENNRVVISSDVLVNN"
        },
        {
            "name": "NSP3",
            "start": 2720,
            "end": 8554,
            "row": 0,
            "color": "#7209b7",
            "sequence": "APTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGG"
        },
        {
            "name": "NSP4",
            "start": 8555,
            "end": 10054,
            "row": 0,
            "color": "#560bad",
            "sequence": "KIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQ"
        },
        {
            "name": "NSP15 (endoRNAse)",
            "start": 19621,
            "end": 20658,
            "row": 0,
            "color": "#38a3a5",
            "sequence": "SLENVAFNVVNKGHFDGQQGEVPVSIINNTVYTKVDGVDVELFENKTTLPVNVAFELWAKRNIKPVPEVKILNNLGVDIAANTVIWDYKRDAPAHISTIGVCSMTDIAKKPTETICAPLTVFFDGRVDGQVDLFRNARNGVLITEGSVKGLQPSVGPKQASLNGVTLIGEAVKTQFNYYKKVDGVVQQLPETYFTQSRNLQEFKPRSQMEIDFLELAMDEFIERYKLEGYAFEHIVYGDFSHSQLGGLHLLIGLAKRFKESPFELEDFIPMDSTVKNYFITDAQTGSSKCVCSVIDLLLDDFVEIIKSQDLSVVSKVVKVTIDYTEISFMLWCKDGHVETFYPKLQ"
        },
        {
            "name": "NSP5 (3C-like proteinase)",
            "start": 10055,
            "end": 10972,
            "row": 0,
            "color": "#480ca8",
            "sequence": "SGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQ"
        },
        {
            "name": "NSP14 (3'-to-5' exonuclease)",
            "start": 18040,
            "end": 19620,
            "row": 0,
            "color": "#57cc99",
            "sequence": "AENVTGLFKDCSKVITGLHPTQAPTHLSVDTKFKTEGLCVDIPGIPKDMTYRRLISMMGFKMNYQVNGYPNMFITREEAIRHVRAWIGFDVEGCHATREAVGTNLPLQLGFSTGVNLVAVPTGYVDTPNNTDFSRVSAKPPPGDQFKHLIPLMYKGLPWNVVRIKIVQMLSDTLKNLSDRVVFVLWAHGFELTSMKYFVKIGPERTCCLCDRRATCFSTASDTYACWHHSIGFDYVYNPFMIDVQQWGFTGNLQSNHDLYCQVHGNAHVASCDAIMTRCLAVHECFVKRVDWTIEYPIIGDELKINAACRKVQHMVVKAALLADKFPVLHDIGNPKAIKCVPQADVEWKFYDAQPCSDKAYKIEELFYSYATHSDKFTDGVCLFWNCNVDRYPANSIVCRFDTRVLSNLNLPGCDGGSLYVNKHAFHTPAFDKSAFVNLKQLPFFYYSDSPCESHGKQVVSDIDYVPLKSATCITRCNLGGAVCRHHANEYRLYLDAYNMMISAGFSLWVYKQFDTYNLWNTFTRLQ"
        },
        {
            "name": "NSP11",
            "start": 13442,
            "end": 13480,
            "row": 0,
            "color": "#65bc6e",
            "sequence": "SADAQSFLNGFAV"
        },
        {
            "name": "NSP13 (helicase)",
            "start": 16237,
            "end": 18039,
            "row": 0,
            "color": "#80ed99",
            "sequence": "AVGACVLCNSQTSLRCGACIRRPFLCCKCCYDHVISTSHKLVLSVNPYVCNAPGCDVTDVTQLYLGGMSYYCKSHKPPISFPLCANGQVFGLYKNTCVGSDNVTDFNAIATCDWTNAGDYILANTCTERLKLFAAETLKATEETFKLSYGIATVREVLSDRELHLSWEVGKPRPPLNRNYVFTGYRVTKNSKVQIGEYTFEKGDYGDAVVYRGTTTYKLNVGDYFVLTSHTVMPLSAPTLVPQEHYVRITGLYPTLNISDEFSSNVANYQKVGMQKYSTLQGPPGTGKSHFAIGLALYYPSARIVYTACSHAAVDALCEKALKYLPIDKCSRIIPARARVECFDKFKVNSTLEQYVFCTVNALPETTADIVVFDEISMATNYDLSVVNARLRAKHYVYIGDPAQLPAPRTLLTKGTLEPEYFNSVCRLMKTIGPDMFLGTCRRCPAEIVDTVSALVYDNKLKAHKDKSAQCFKMFYKGVITHDVSSAINRPQIGVVREFLTRNPAWRKAVFISPYNSQNAVASKILGLPTQTVDSSQGSEYDYVIFTQTTETAHSCNVNRFNVAITRAKVGILCIMSDRDLYDKLQFTSLEIPRRNVATLQ"
        },
        {
            "name": "NSP6",
            "start": 10973,
            "end": 11842,
            "row": 0,
            "color": "#3a0ca3",
            "sequence": "SAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQ"
        },
        {
            "name": "NSP7",
            "start": 11843,
            "end": 12091,
            "row": 0,
            "color": "#3f37c9",
            "sequence": "SKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQ"
        },
        {
            "name": "NSP8",
            "start": 12092,
            "end": 12685,
            "row": 0,
            "color": "#4361ee",
            "sequence": "AIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQ"
        },
        {
            "name": "NSP9",
            "start": 12686,
            "end": 13024,
            "row": 0,
            "color": "#4895ef",
            "sequence": "NNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQ"
        },
        {
            "name": "NSP12 (RNA-dependent RNA polymerase)",
            "start": 13442,
            "end": 16236,
            "row": 0,
            "color": "#c7f9cc",
            "sequence": "SADAQSFLNRVCGVSAARLTPCGTGTSTDVVYRAFDIYNDKVAGFAKFLKTNCCRFQEKDEDDNLIDSYFVVKRHTFSNYQHEETIYNLLKDCPAVAKHDFFKFRIDGDMVPHISRQRLTKYTMADLVYALRHFDEGNCDTLKEILVTYNCCDDDYFNKKDWYDFVENPDILRVYANLGERVRQALLKTVQFCDAMRNAGIVGVLTLDNQDLNGNWYDFGDFIQTTPGSGVPVVDSYYSLLMPILTLTRALTAESHVDTDLTKPYIKWDLLKYDFTEERLKLFDRYFKYWDQTYHPNCVNCLDDRCILHCANFNVLFSTVFPPTSFGPLVRKIFVDGVPFVVSTGYHFRELGVVHNQDVNLHSSRLSFKELLVYAADPAMHAASGNLLLDKRTTCFSVAALTNNVAFQTVKPGNFNKDFYDFAVSKGFFKEGSSVELKHFFFAQDGNAAISDYDYYRYNLPTMCDIRQLLFVVEVVDKYFDCYDGGCINANQVIVNNLDKSAGFPFNKWGKARLYYDSMSYEDQDALFAYTKRNVIPTITQMNLKYAISAKNRARTVAGVSICSTMTNRQFHQKLLKSIAATRGATVVIGTSKFYGGWHNMLKTVYSDVENPHLMGWDYPKCDRAMPNMLRIMASLVLARKHTTCCSLSHRFYRLANECAQVLSEMVMCGGSLYVKPGGTSSGDATTAYANSVFNICQAVTANVNALLSTDGNKIADKYVRNLQHRLYECLYRNRDVDTDFVNEFYAYLRKHFSMMILSDDAVVCFNSTYASQGLVASIKNFKSVLYYQNNVFMSEAKCWTETDLTKGPHEFCSQHTMLVKQGDDYVYLPYPDPSRILGAGCFVDDIVKTDGTLMIERFVSLAIDAYPLTKHPNQEYADVFHLYLQYIRKLHDELTGHMLDMYSVMLTNDNTSRYWEPEFYEAMYTPHTVLQ"
        },
        {
            "name": "ORF1ab polyprotein",
            "start": 266,
            "end": 21555,
            "row": 0,
            "color": "#89c4be",
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGGAYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGGAPTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGGKIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQSGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQSAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQSKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQAIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQNNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQAGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQSADAQSFLNRVCGVSAARLTPCGTGTSTDVVYRAFDIYNDKVAGFAKFLKTNCCRFQEKDEDDNLIDSYFVVKRHTFSNYQHEETIYNLLKDCPAVAKHDFFKFRIDGDMVPHISRQRLTKYTMADLVYALRHFDEGNCDTLKEILVTYNCCDDDYFNKKDWYDFVENPDILRVYANLGERVRQALLKTVQFCDAMRNAGIVGVLTLDNQDLNGNWYDFGDFIQTTPGSGVPVVDSYYSLLMPILTLTRALTAESHVDTDLTKPYIKWDLLKYDFTEERLKLFDRYFKYWDQTYHPNCVNCLDDRCILHCANFNVLFSTVFPPTSFGPLVRKIFVDGVPFVVSTGYHFRELGVVHNQDVNLHSSRLSFKELLVYAADPAMHAASGNLLLDKRTTCFSVAALTNNVAFQTVKPGNFNKDFYDFAVSKGFFKEGSSVELKHFFFAQDGNAAISDYDYYRYNLPTMCDIRQLLFVVEVVDKYFDCYDGGCINANQVIVNNLDKSAGFPFNKWGKARLYYDSMSYEDQDALFAYTKRNVIPTITQMNLKYAISAKNRARTVAGVSICSTMTNRQFHQKLLKSIAATRGATVVIGTSKFYGGWHNMLKTVYSDVENPHLMGWDYPKCDRAMPNMLRIMASLVLARKHTTCCSLSHRFYRLANECAQVLSEMVMCGGSLYVKPGGTSSGDATTAYANSVFNICQAVTANVNALLSTDGNKIADKYVRNLQHRLYECLYRNRDVDTDFVNEFYAYLRKHFSMMILSDDAVVCFNSTYASQGLVASIKNFKSVLYYQNNVFMSEAKCWTETDLTKGPHEFCSQHTMLVKQGDDYVYLPYPDPSRILGAGCFVDDIVKTDGTLMIERFVSLAIDAYPLTKHPNQEYADVFHLYLQYIRKLHDELTGHMLDMYSVMLTNDNTSRYWEPEFYEAMYTPHTVLQAVGACVLCNSQTSLRCGACIRRPFLCCKCCYDHVISTSHKLVLSVNPYVCNAPGCDVTDVTQLYLGGMSYYCKSHKPPISFPLCANGQVFGLYKNTCVGSDNVTDFNAIATCDWTNAGDYILANTCTERLKLFAAETLKATEETFKLSYGIATVREVLSDRELHLSWEVGKPRPPLNRNYVFTGYRVTKNSKVQIGEYTFEKGDYGDAVVYRGTTTYKLNVGDYFVLTSHTVMPLSAPTLVPQEHYVRITGLYPTLNISDEFSSNVANYQKVGMQKYSTLQGPPGTGKSHFAIGLALYYPSARIVYTACSHAAVDALCEKALKYLPIDKCSRIIPARARVECFDKFKVNSTLEQYVFCTVNALPETTADIVVFDEISMATNYDLSVVNARLRAKHYVYIGDPAQLPAPRTLLTKGTLEPEYFNSVCRLMKTIGPDMFLGTCRRCPAEIVDTVSALVYDNKLKAHKDKSAQCFKMFYKGVITHDVSSAINRPQIGVVREFLTRNPAWRKAVFISPYNSQNAVASKILGLPTQTVDSSQGSEYDYVIFTQTTETAHSCNVNRFNVAITRAKVGILCIMSDRDLYDKLQFTSLEIPRRNVATLQAENVTGLFKDCSKVITGLHPTQAPTHLSVDTKFKTEGLCVDIPGIPKDMTYRRLISMMGFKMNYQVNGYPNMFITREEAIRHVRAWIGFDVEGCHATREAVGTNLPLQLGFSTGVNLVAVPTGYVDTPNNTDFSRVSAKPPPGDQFKHLIPLMYKGLPWNVVRIKIVQMLSDTLKNLSDRVVFVLWAHGFELTSMKYFVKIGPERTCCLCDRRATCFSTASDTYACWHHSIGFDYVYNPFMIDVQQWGFTGNLQSNHDLYCQVHGNAHVASCDAIMTRCLAVHECFVKRVDWTIEYPIIGDELKINAACRKVQHMVVKAALLADKFPVLHDIGNPKAIKCVPQADVEWKFYDAQPCSDKAYKIEELFYSYATHSDKFTDGVCLFWNCNVDRYPANSIVCRFDTRVLSNLNLPGCDGGSLYVNKHAFHTPAFDKSAFVNLKQLPFFYYSDSPCESHGKQVVSDIDYVPLKSATCITRCNLGGAVCRHHANEYRLYLDAYNMMISAGFSLWVYKQFDTYNLWNTFTRLQSLENVAFNVVNKGHFDGQQGEVPVSIINNTVYTKVDGVDVELFENKTTLPVNVAFELWAKRNIKPVPEVKILNNLGVDIAANTVIWDYKRDAPAHISTIGVCSMTDIAKKPTETICAPLTVFFDGRVDGQVDLFRNARNGVLITEGSVKGLQPSVGPKQASLNGVTLIGEAVKTQFNYYKKVDGVVQQLPETYFTQSRNLQEFKPRSQMEIDFLELAMDEFIERYKLEGYAFEHIVYGDFSHSQLGGLHLLIGLAKRFKESPFELEDFIPMDSTVKNYFITDAQTGSSKCVCSVIDLLLDDFVEIIKSQDLSVVSKVVKVTIDYTEISFMLWCKDGHVETFYPKLQSSQAWQPGVAMPNLYKMQRMLLEKCDLQNYGDSATLPKGIMMNVAKYTQLCQYLNTLTLAVPYNMRVIHFGAGSDKGVAPGTAVLRQWLPTGTLLVDSDLNDFVSDADSTLIGDCATVHTANKWDLIISDMYDPKTKNVTKENDSKEGFFTYICGFIQQKLALGGSVAIKITEHSWNADLYKLMGHFAWWTAFVTNVNASSSEAFLIGCNYLGKPREQIDGYVMHANYIFWRNTNPIQLSSYSLFDMSKFPLKLRGTAVMSLKEGQINDMILSLLSKGRLIIRENNRVVISSDVLVNN"
        },
        {
            "name": "NSP10",
            "start": 13025,
            "end": 13441,
            "row": 0,
            "color": "#4cc9f0",
            "sequence": "AGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQ"
        },
        {
            "name": "NSP1 (leader protein)",
            "start": 266,
            "end": 805,
            "row": 0,
            "color": "#f72585",
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGG"
        },
        {
            "name": "ORF1a polyprotein",
            "start": 266,
            "end": 13483,
            "row": 0,
            "sequence": "MESLVPGFNEKTHVQLSLPVLQVRDVLVRGFGDSVEEVLSEARQHLKDGTCGLVEVEKGVLPQLEQPYVFIKRSDARTAPHGHVMVELVAELEGIQYGRSGETLGVLVPHVGEIPVAYRKVLLRKNGNKGAGGHSYGADLKSFDLGDELGTDPYEDFQENWNTKHSSGVTRELMRELNGGAYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGGAPTKVTFGDDTVIEVQGYKSVNITFELDERIDKVLNEKCSAYTVELGTEVNEFACVVADAVIKTLQPVSELLTPLGIDLDEWSMATYYLFDESGEFKLASHMYCSFYPPDEDEEEGDCEEEEFEPSTQYEYGTEDDYQGKPLEFGATSAALQPEEEQEEDWLDDDSQQTVGQQDGSEDNQTTTIQTIVEVQPQLEMELTPVVQTIEVNSFSGYLKLTDNVYIKNADIVEEAKKVKPTVVVNAANVYLKHGGGVAGALNKATNNAMQVESDDYIATNGPLKVGGSCVLSGHNLAKHCLHVVGPNVNKGEDIQLLKSAYENFNQHEVLLAPLLSAGIFGADPIHSLRVCVDTVRTNVYLAVFDKNLYDKLVSSFLEMKSEKQVEQKIAEIPKEEVKPFITESKPSVEQRKQDDKKIKACVEEVTTTLEETKFLTENLLLYIDINGNLHPDSATLVSDIDITFLKKDAPYIVGDVVQEGVLTAVVIPTKKAGGTTEMLAKALRKVPTDNYITTYPGQGLNGYTVEEAKTVLKKCKSAFYILPSIISNEKQEILGTVSWNLREMLAHAEETRKLMPVCVETKAIVSTIQRKYKGIKIQEGVVDYGARFYFYTSKTTVASLINTLNDLNETLVTMPLGYVTHGLNLEEAARYMRSLKVPATVSVSSPDAVTAYNGYLTSSSKTPEEHFIETISLAGSYKDWSYSGQSTQLGIEFLKRGDKSVYYTSNPTTFHLDGEVITFDNLKTLLSLREVRTIKVFTTVDNINLHTQVVDMSMTYGQQFGPTYLDGADVTKIKPHNSHEGKTFYVLPNDDTLRVEAFEYYHTTDPSFLGRYMSALNHTKKWKYPQVNGLTSIKWADNNCYLATALLTLQQIELKFNPPALQDAYYRARAGEAANFCALILAYCNKTVGELGDVRETMSYLFQHANLDSCKRVLNVVCKTCGQQQTTLKGVEAVMYMGTLSYEQFKKGVQIPCTCGKQATKYLVQQESPFVMMSAPPAQYELKHGTFTCASEYTGNYQCGHYKHITSKETLYCIDGALLTKSSEYKGPITDVFYKENSYTTTIKPVTYKLDGVVCTEIDPKLDNYYKKDNSYFTEQPIDLVPNQPYPNASFDNFKFVCDNIKFADDLNQLTGYKKPASRELKVTFFPDLNGDVVAIDYKHYTPSFKKGAKLLHKPIVWHVNNATNKATYKPNTWCIRCLWSTKPVETSNSFDVLKSEDAQGMDNLACEDLKPVSEEVVENPTIQKDVLECNVKTTEVVGDIILKPANNSLKITEEVGHTDLMAAYVDNSSLTIKKPNELSRVLGLKTLATHGLAAVNSVPWDTIANYAKPFLNKVVSTTTNIVTRCLNRVCTNYMPYFFTLLLQLCTFTRSTNSRIKASMPTTIAKNTVKSVGKFCLEASFNYLKSPNFSKLINIIIWFLLLSVCLGSLIYSTAALGVLMSNLGMPSYCTGYREGYLNSTNVTIATYCTGSIPCSVCLSGLDSLDTYPSLETIQITISSFKWDLTAFGLVAEWFLAYILFTRFFYVLGLAAIMQLFFSYFAVHFISNSWLMWLIINLVQMAPISAMVRMYIFFASFYYVWKSYVHVVDGCNSSTCMMCYKRNRATRVECTTIVNGVRRSFYVYANGGKGFCKLHNWNCVNCDTFCAGSTFISDEVARDLSLQFKRPINPTDQSSYIVDSVTVKNGSIHLYFDKAGQKTYERHSLSHFVNLDNLRANNTKGSLPINVIVFDGKSKCEESSAKSASVYYSQLMCQPILLLDQALVSDVGDSAEVAVKMFDAYVNTFSSTFNVPMEKLKTLVATAEAELAKNVSLDNVLSTFISAARQGFVDSDVETKDVVECLKLSHQSDIEVTGDSCNNYMLTYNKVENMTPRDLGACIDCSARHINAQVAKSHNIALIWNVKDFMSLSEQLRKQIRSAAKKNNLPFKLTCATTRQVVNVVTTKIALKGGKIVNNWLKQLIKVTLVFLFVAAIFYLITPVHVMSKHTDFSSEIIGYKAIDGGVTRDIASTDTCFANKHADFDTWFSQRGGSYTNDKACPLIAAVITREVGFVVPGLPGTILRTTNGDFLHFLPRVFSAVGNICYTPSKLIEYTDFATSACVLAAECTIFKDASGKPVPYCYDTNVLEGSVAYESLRPDTRYVLMDGSIIQFPNTYLEGSVRVVTTFDSEYCRHGTCERSEAGVCVSTSGRWVLNNDYYRSLPGVFCGVDAVNLLTNMFTPLIQPIGALDISASIVAGGIVAIVVTCLAYYFMRFRRAFGEYSHVVAFNTLLFLMSFTVLCLTPVYSFLPGVYSVIYLYLTFYLTNDVSFLAHIQWMVMFTPLVPFWITIAYIICISTKHFYWFFSNYLKRRVVFNGVSFSTFEEAALCTFLLNKEMYLKLRSDVLLPLTQYNRYLALYNKYKYFSGAMDTTSYREAACCHLAKALNDFSNSGSDVLYQPPQTSITSAVLQSGFRKMAFPSGKVEGCMVQVTCGTTTLNGLWLDDVVYCPRHVICTSEDMLNPNYEDLLIRKSNHNFLVQAGNVQLRVIGHSMQNCVLKLKVDTANPKTPKYKFVRIQPGQTFSVLACYNGSPSGVYQCAMRPNFTIKGSFLNGSCGSVGFNIDYDCVSFCYMHHMELPTGVHAGTDLEGNFYGPFVDRQTAQAAGTDTTITVNVLAWLYAAVINGDRWFLNRFTTTLNDFNLVAMKYNYEPLTQDHVDILGPLSAQTGIAVLDMCASLKELLQNGMNGRTILGSALLEDEFTPFDVVRQCSGVTFQSAVKRTIKGTHHWLLLTILTSLLVLVQSTQWSLFFFLYENAFLPFAMGIIAMSAFAMMFVKHKHAFLCLFLLPSLATVAYFNMVYMPASWVMRIMTWLDMVDTSLSGFKLKDCVMYASAVVLLILMTARTVYDDGARRVWTLMNVLTLVYKVYYGNALDQAISMWALIISVTSNYSGVVTTVMFLARGIVFMCVEYCPIFFITGNTLQCIMLVYCFLGYFCTCYFGLFCLLNRYFRLTLGVYDYLVSTQEFRYMNSQGLLPPKNSIDAFKLNIKLLGVGGKPCIKVATVQSKMSDVKCTSVVLLSVLQQLRVESSSKLWAQCVQLHNDILLAKDTTEAFEKMVSLLSVLLSMQGAVDINKLCEEMLDNRATLQAIASEFSSLPSYAAFATAQEAYEQAVANGDSEVVLKKLKKSLNVAKSEFDRDAAMQRKLEKMADQAMTQMYKQARSEDKRAKVTSAMQTMLFTMLRKLDNDALNNIINNARDGCVPLNIIPLTTAAKLMVVIPDYNTYKNTCDGTTFTYASALWEIQQVVDADSKIVQLSEISMDNSPNLAWPLIVTALRANSAVKLQNNELSPVALRQMSCAAGTTQTACTDDNALAYYNTTKGGRFVLALLSDLQDLKWARFPKSDGTGTIYTELEPPCRFVTDTPKGPKVKYLYFIKGLNNLNRGMVLGSLAATVRLQAGNATEVPANSTVLSFCAFAVDAAKAYKDYLASGGQPITNCVKMLCTHTGTGQAITVTPEANMDQESFGGASCCLYCRCHIDHPNPKGFCDLKGKYVQIPTTCANDPVGFTLKNTVCTVCGMWKGYGCSCDQLREPMLQSADAQSFLNGFAV"
        },
        {
            "name": "NSP2",
            "start": 806,
            "end": 2719,
            "row": 0,
            "color": "#ccb7ae",
            "sequence": "AYTRYVDNNFCGPDGYPLECIKDLLARAGKASCTLSEQLDFIDTKRGVYCCREHEHEIAWYTERSEKSYELQTPFEIKLAKKFDTFNGECPNFVFPLNSIIKTIQPRVEKKKLDGFMGRIRSVYPVASPNECNQMCLSTLMKCDHCGETSWQTGDFVKATCEFCGTENLTKEGATTCGYLPQNAVVKIYCPACHNSEVGPEHSLAEYHNESGLKTILRKGGRTIAFGGCVFSYVGCHNKCAYWVPRASANIGCNHTGVVGEGSEGLNDNLLEILQKEKVNINIVGDFKLNEEIAIILASFSASTSAFVETVKGLDYKAFKQIVESCGNFKVTKGKAKKGAWNIGEQKSILSPLYAFASEAARVVRSIFSRTLETAQNSVRVLQKAAITILDGISQYSLRLIDAMMFTSDLATNNLVVMAYITGGVVQLTSQWLTNIFGTVYEKLKPVLDWLEEKFKEGVEFLRDGWEIVKFISTCACEIVGGQIVTCAKEIKESVQTFFKLVNKFLALCADSIIIGGAKLKALNLGETFVTHSKGLYRKCVKSREETGLLMPLKAPKEIIFLEGETLPTEVLTEEVVLKTGDLQPLEQPTSEAVEAPLVGTPVCINGLMLLEIKDTEKYCALAPNMMVTNNTFTLKGG"
        },
        {
            "name": "NS3 (ORF3a protein)",
            "start": 25393,
            "end": 26220,
            "row": 0,
            "color": "#a3a3a3",
            "sequence": "MDLFMRIFTIGTVTLKQGEIKDATPSDFVRATATIPIQASLPFGWLIVGVALLAVFQSASKIITLKKRWQLALSKGVHFVCNLLLLFVTVYSHLLLVAAGLEAPFLYLYALVYFLQSINFVRIIMRLWLCWKCRSKNPLLYDANYFLCWHTNCYDYCIPYNSVTSSIVITSGDGTTSPISEHDYQIGGYTEKWESGVKDCVVLHSYFTSDYYQLYSTQLSTDTGVEHVTFFIYNKIVDEPEEHVQIHTIDGSSGVVNPVMEPIYDEPTTTTSVPL"
        },
        {
            "name": "NS6 (ORF6 protein)",
            "start": 27202,
            "end": 27387,
            "row": 0,
            "color": "#586ba4",
            "sequence": "MFHLVDFQVTIAEILLIIMRTFKVSIWNLDYIINLIIKNLSKSLTENKYSQLDEEQPMEID"
        },
        {
            "name": "NS7a (ORF7a protein)",
            "start": 27394,
            "end": 27759,
            "row": 0,
            "color": "#324376",
            "sequence": "MKIILFLALITLATCELYHYQECVRGTTVLLKEPCSSGTYEGNSPFHPLADNKFALTCFSTQFAFACPDGVKHVYQLRARSVSPKLFIRQEEVQELYSPIFLIVAAIVFITLCFTLKRKTE"
        },
        {
            "name": "NS7b (ORF7b)",
            "start": 27756,
            "end": 27887,
            "row": 0,
            "color": "#f5dd90",
            "sequence": "MIELSLIDFYLCFLAFLLFLVLIMLIIFWFSLELQDHNETCHA"
        },
        {
            "name": "NS8 (ORF8 protein)",
            "start": 27894,
            "end": 28259,
            "row": 0,
            "color": "#b79738",
            "sequence": "MKFLVFLGIITTVAAFHQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEAGSKSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI"
        },
        {
            "name": "Spike (surface glycoprotein)",
            "start": 21563,
            "end": 25384,
            "row": 0,
            "color": "#accbe1",
            "sequence": "MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDKVEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT"
        }
    ],
    "N": [
        {
            "name": "ORF10",
            "start": 29558,
            "end": 29674,
            "row": 0
        },
        {
            "name": "ORF1ab",
            "start": 266,
            "end": 21555,
            "row": 0
        },
        {
            "name": "ORF3a",
            "start": 25393,
            "end": 26220,
            "row": 0
        },
        {
            "name": "ORF6",
            "start": 27202,
            "end": 27387,
            "row": 0
        },
        {
            "name": "ORF7a",
            "start": 27394,
            "end": 27759,
            "row": 0
        },
        {
            "name": "ORF7b",
            "start": 27756,
            "end": 27887,
            "row": 0
        },
        {
            "name": "ORF8",
            "start": 27894,
            "end": 28259,
            "row": 0
        }
    ]
}


########################################################################################################


@api.route('/allGeo')
class FieldList(Resource):
    @api.doc('all_geo')
    def get(self):
        all_geo = all_geo_dict['all_geo']
        return all_geo


@api.route('/allLineages')
class FieldList(Resource):
    @api.doc('all_lineages')
    def get(self):
        all_lin = all_lineage_dict['all_lineage']
        return all_lin


@api.route('/allProtein')
class FieldList(Resource):
    @api.doc('all_protein')
    def get(self):
        all_protein = all_protein_dict['all_protein']
        return all_protein


@api.route('/tableLineageCountry')
class FieldList(Resource):
    @api.doc('table_lineage_country')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/tableLineageCountry', json_data, headers)

        response = conn.getresponse()
        all_geo = response.read().decode()
        all_geo = json.loads(all_geo)

        table = []
        for item in all_geo:
            single_line = {'lineage': item['lineage']}
            country_count = item['country_count']
            country_count = country_count.replace('"', "")
            country_count = country_count.replace("\\", "")
            country_count = country_count.replace("{", "")
            country_count = country_count.replace("}", "")
            country_count = country_count.replace("(", "")
            array_country_count = country_count.split("),")
            for single_country in array_country_count:
                single_country = single_country.replace(")", "")
                array_single_country = single_country.split(',')
                single_line[array_single_country[0]] = array_single_country[1]
            table.append(single_line)

        return table


@api.route('/possibleCountryLineage')
class FieldList(Resource):
    @api.doc('possible_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/arrayCountryForLineage', json_data, headers)

        response = conn.getresponse()
        all_country = response.read().decode()
        all_country = all_country.replace(']', '').replace('[', '')
        all_country = all_country.replace('"', '').split(",")

        return all_country


@api.route('/denominatorLineageCountry')
class FieldList(Resource):
    @api.doc('possible_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/denominatorLineageCountry', json_data, headers)

        response = conn.getresponse()
        resp = response.read().decode()
        resp = json.loads(resp)

        denominators = {}

        for item in resp:
            if item['geo'] is None:
                denominators['N/D'] = item['cnt']
            else:
                denominators[item['geo']] = item['cnt']

        return denominators


@api.route('/analyzeMutationCountryLineage')
class FieldList(Resource):
    @api.doc('analyze_mutation_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationCountryLineage', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['country']
            single_item['background'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_country']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_country']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_country'],
                                                   item['numerator'] / item['denominator'])
            else:
                single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_country'],
                                                       item['numerator'] / item['denominator'])

            mutation_table2.append(single_item)

        return mutation_table2


@api.route('/analyzeMutationCountryLineageInTime')
class FieldList(Resource):
    @api.doc('analyze_mutation_country_lineage_in_time')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationCountryLineageInTime', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['target_time']
            single_item['background'] = item['background_time']
            single_item['country'] = item['country']
            single_item['lineage'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                                                       item['numerator'] / item['denominator'])
            else:
                single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                                                       item['numerator'] / item['denominator'])

            mutation_table2.append(single_item)

        return mutation_table2


@api.route('/analyzeTimeDistributionCountryLineage')
class FieldList(Resource):
    @api.doc('analyze_time_distribution_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeTimeDistributionCountryLineage', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/analyzeTimeDistributionBackgroundQueryGeo')
class FieldList(Resource):
    @api.doc('analyze_time_distribution_country_lineage')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeTimeDistributionBackgroundQueryGeo', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/analyzeMutationProvinceRegion')
class FieldList(Resource):
    @api.doc('analyze_mutation_province_region')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationProvinceRegion', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            # if 'country' in item:
            #    single_item['target'] = item['region']
            #    single_item['background'] = item['country']
            # else:
            #    single_item['target'] = item['province']
            #    single_item['background'] = item['region']
            single_item['target'] = item['target']
            single_item['background'] = item['background']

            single_item['lineage'] = item['lineage']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                                                       item['numerator'] / item['denominator'])
            else:
                single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                                                       item['numerator'] / item['denominator'])

            mutation_table2.append(single_item)

        return mutation_table2


@api.route('/analyzeMutationTargetBackgroundFree')
class FieldList(Resource):
    @api.doc('analyze_mutation_target_background_free')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/analyzeMutationTargetBackgroundFree', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        mutation_table2 = []
        for item in all_result:
            single_item = {}
            if item['product'] == 'Spike (surface glycoprotein)':
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
                # mutation = 'S_'
            else:
                protein = item['product'].split(" ", 1)[0]
                mutation = protein + '_'
            mutation += item['sequence_aa_original'] + str(item['start_aa_original']) + item['sequence_aa_alternative']
            single_item['start_aa_original'] = item['start_aa_original']
            single_item['sequence_aa_original'] = item['sequence_aa_original']
            single_item['sequence_aa_alternative'] = item['sequence_aa_alternative']
            single_item['mutation'] = mutation
            single_item['product'] = item['product']
            single_item['mutation_position'] = item['start_aa_original']
            single_item['target'] = item['target']
            single_item['background'] = item['background']

            single_item['lineage'] = item['lineage']
            single_item['lineage_target'] = item['lineage_target']
            single_item['lineage_background'] = item['lineage_background']
            single_item['count_target'] = item['count_seq']
            single_item['percentage_background'] = item['fraction']
            single_item['numerator_background'] = item['numerator']
            single_item['denominator_background'] = item['denominator']
            single_item['percentage_target'] = item['fraction_target']
            single_item['numerator_target'] = item['count_seq']
            single_item['denominator_target'] = item['denominator_target']

            epsilon = 0.00000001
            single_item['odd_ratio'] = (single_item['percentage_target'] + epsilon) / \
                                       (single_item['percentage_background'] + epsilon)

            if single_item['odd_ratio'] >= 1:
                if item['denominator'] != 0:
                    single_item['p_value'] = 1 - binom.cdf(item['count_seq'] - 1, item['denominator_target'],
                                                       item['numerator'] / item['denominator'])
                else:
                    single_item['p_value'] = 0
            else:
                if item['denominator'] != 0:
                    single_item['p_value'] = binom.cdf(item['count_seq'], item['denominator_target'],
                                                       item['numerator'] / item['denominator'])
                else:
                    single_item['p_value'] = 0

            mutation_table2.append(single_item)

        return mutation_table2


@api.route('/countOverlappingSequenceTargetBackground')
class FieldList(Resource):
    @api.doc('count_overlapping_sequence_target_background')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/countOverlappingSequenceTargetBackground', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/selectorQuery')
class FieldList(Resource):
    @api.doc('selector_query')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/selectorQuery', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/getAccessionIds')
class FieldList(Resource):
    @api.doc('selector_query')
    def post(self):

        to_send = api.payload

        conn = http.client.HTTPConnection('geco.deib.polimi.it')
        headers = {'Content-type': 'application/json'}
        send = to_send
        json_data = json.dumps(send)
        conn.request('POST', '/virusurf_epitope/api/epitope/getAccessionIds', json_data, headers)

        response = conn.getresponse()
        all_result = response.read().decode()
        all_result = json.loads(all_result)

        return all_result


@api.route('/getProteinPosition')
class FieldList(Resource):
    @api.doc('get_protein_position')
    def post(self):

        payload = api.payload
        name_protein = payload['protein']

        all_protein = sars_cov_2_products['A']
        min_pos = 0
        max_pos = 0
        for item in all_protein:
            name = str(item.get('name'))
            if name.lower() == name_protein.lower():
                min_pos = 1
                max_pos = (item.get('end') - item.get('start')) // 3
                if "nsp" in name.lower():
                    max_pos = max_pos + 1

        res = {'start': min_pos, 'stop': max_pos}

        return res


@api.route('/getDomains')
class FieldList(Resource):
    @api.doc('get_domains')
    def post(self):

        payload = api.payload
        name_protein = payload['protein']

        annotations = pd.read_csv("apis/protein_annotations.csv",
                                  delimiter=',')

        annotations1 = copy.deepcopy(annotations)
        annotations2 = copy.deepcopy(annotations)
        annotations3 = copy.deepcopy(annotations)

        ann_mutagenesis = annotations1[(annotations.Description.str.lower() != 'n/d')
                                      & (annotations.Protein.str.lower() == name_protein.lower())
                                      & (annotations.Category.str.lower() == 'mutagenesis')
                                      ]
        ann_mutagenesis2 = ann_mutagenesis[['Description', 'Begin', 'End']]
        ann_mutagenesis3 = json.loads(ann_mutagenesis2.to_json(orient="records"))

        ann_aa_modifications = annotations2[(annotations.Description.str.lower() != 'n/d')
                                      & (annotations.Protein.str.lower() == name_protein.lower())
                                      & (annotations.Category.str.lower() == 'ptm')
                                      & (annotations.Type.str.lower() == 'carbohyd')
                                      ]
        ann_aa_modifications2 = ann_aa_modifications[['Description', 'Begin', 'End']]
        ann_aa_modifications3 = json.loads(ann_aa_modifications2.to_json(orient="records"))
        print("ann", ann_aa_modifications3)

        ann_sites_family_dom = annotations3[(annotations.Description.str.lower() != 'n/d')
                                           & (annotations.Protein.str.lower() == name_protein.lower())
                                           & ((annotations.Category.str.lower() == 'domains_and_sites') |
                                              (annotations.Type.str.lower() == 'n/d'))
                                           ]
        ann_sites_family_dom2 = ann_sites_family_dom[['Description', 'Begin', 'End']]
        ann_sites_family_dom3 = json.loads(ann_sites_family_dom2.to_json(orient="records"))

        result = {'mutagenesis': ann_mutagenesis3, 'aa_modifications': ann_aa_modifications3,
                  'sites_and_domains': ann_sites_family_dom3}

        return result


@api.route('/getImportantMutation')
class FieldList(Resource):
    @api.doc('get_important_mutation')
    def post(self):

        payload = api.payload
        name_lineage = payload['lineage']

        result = {'mutation': [], 'additional_mutation': []}

        if name_lineage in dict_lineage_mutation:
            lineage_json = dict_lineage_mutation[name_lineage]
            result['mutation'] = lineage_json['mutation']
            result['additional_mutation'] = lineage_json['additional_mutation']
        else:
            all_mutation = []
            all_additional_mutation = []
            for lineage in dict_lineage_mutation:
                row = dict_lineage_mutation[lineage]
                for mutation in row['mutation']:
                    if mutation not in all_mutation:
                        all_mutation.append(mutation)
                    if mutation in all_additional_mutation:
                        all_additional_mutation.remove(mutation)
                for additional_mutation in row['additional_mutation']:
                    if additional_mutation not in all_additional_mutation and additional_mutation not in all_mutation:
                        all_additional_mutation.append(additional_mutation)
            result['mutation'] = all_mutation
            result['additional_mutation'] = all_additional_mutation

        return result


@api.route('/getLineageTree')
class FieldList(Resource):
    @api.doc('get_lineage_tree')
    def post(self):

        payload = api.payload
        possible_lineages = payload['possibleLineages']

        dict_copy = dict_lineage_mutation

        arr_lineages = []
        dict_lineages = {}
        for item in possible_lineages:
            single_line = item
            dict_lineages[item['value']] = single_line
            arr_lineages.append(item['value'])

        dict_copy2 = dict(sorted(dict_copy.items(), key=lambda k_v: k_v[1]['alias']))

        items = []
        idx = 1

        for lineage in dict_copy2:
            already_done = False
            children = False
            children_lineage = False
            important_lineage = False
            alias = dict_copy2[lineage]['alias']
            if lineage in arr_lineages:
                if dict_copy2[lineage]['WHO label'] != '':
                    important_lineage = True
                for itm in items:
                    possible_parent_alias = str(itm['alias']) + '.'
                    possible_children_alias = str(alias)
                    possible_parent_lineage = str(itm['real_name']) + '.'
                    possible_children_lineage = str(lineage)
                    if possible_parent_alias in possible_children_alias:
                        children = True
                        recursive_children_lineage(itm, lineage, alias, dict_copy2, dict_lineages)
                    if possible_parent_lineage in possible_children_lineage:
                        children_lineage = True
                        if possible_children_lineage != possible_children_alias:
                            recursive_children_lineage(itm, lineage, lineage, dict_copy2, dict_lineages)
                if not children:
                    already_done = True
                    name_complete = lineage
                    if dict_copy2[lineage]['WHO label'] != '':
                        name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
                    single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage,
                                      'who': dict_copy2[lineage]['WHO label'], 'children': [],
                                      'count': dict_lineages[lineage]['count']}
                    items.append(single_lineage)
                    idx = idx + 1

                if not children_lineage and not already_done:
                    name_complete = lineage.split('.')[0]
                    single_lineage = {'id': idx, 'alias': name_complete, 'name': name_complete, 'real_name': name_complete,
                                      'who': '', 'children': [],
                                      'count': 0}
                    items.append(single_lineage)
                    idx = idx + 1
                    recursive_children_lineage(single_lineage, lineage, lineage, dict_copy2, dict_lineages)

                # if important_lineage and not already_done:
                #     name_complete = lineage
                #     if dict_copy2[lineage]['WHO label'] != '':
                #         name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
                #     single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage,
                #                       'who': dict_copy2[lineage]['WHO label'], 'children': [],
                #                       'count': dict_lineages[lineage]['count']}
                #     items.append(single_lineage)
                #     idx = idx + 1

        return items


@api.route('/getAllImportantMutationPerLineage')
class FieldList(Resource):
    @api.doc('get_important_mutation')
    def post(self):

        payload = api.payload
        lineage = payload['lineage']
        proteins = payload['proteins']

        array_proteins = []

        for protein in proteins:
            protein_rewritten = protein.split(" ")[0]
            array_proteins.append(protein_rewritten)

        dict_copy = all_important_mutation_dict

        array_important_mutation = []

        if lineage is None:
            for lineage_mutations in dict_copy:
                single_lineage_mutation = dict_copy[lineage_mutations]
                for mutation in single_lineage_mutation['common_changes']:
                    if mutation not in array_important_mutation:
                        protein = mutation.split("_")[0]
                        if protein in array_proteins:
                            array_important_mutation.append(mutation)
                            array_important_mutation.sort()
        else:
            if lineage in dict_copy:
                single_lineage_mutation = dict_copy[lineage]
                for mutation in single_lineage_mutation['common_changes']:
                    if mutation not in array_important_mutation:
                        protein = mutation.split("_")[0]
                        if protein in array_proteins:
                            array_important_mutation.append(mutation)
                            array_important_mutation.sort()

        return array_important_mutation


def recursive_children_lineage(parent, lineage, alias, dict_copy2, dict_lineages):
    children = False
    idx = str(parent['id']) + '_' + str(len(parent['children']))
    for itm in parent['children']:
        possible_parent_alias = str(itm['alias']) + '.'
        possible_children_alias = str(alias)
        if possible_parent_alias in possible_children_alias:
            children = True
            recursive_children_lineage(itm, lineage, alias, dict_copy2, dict_lineages)
            break
        else:
            children = False
    if not children:
        name_complete = lineage
        if dict_copy2[lineage]['WHO label'] != '':
            name_complete = lineage + ' (' + dict_copy2[lineage]['WHO label'] + ') '
        single_lineage = {'id': idx, 'alias': alias, 'name': name_complete, 'real_name': lineage, 'who': dict_copy2[lineage]['WHO label'],
                          'children': [], 'count': dict_lineages[lineage]['count']}
        parent['children'].append(single_lineage)


all_important_mutation_dict = {}


def get_all_important_mutation():
    print("inizio request important mutation")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allImportantMutations')

    response = conn.getresponse()
    all_important_mutation = response.read().decode()
    all_important_mutation = json.loads(all_important_mutation)

    for mutation_per_lineage in all_important_mutation:
        lineage = mutation_per_lineage['lineage']
        all_important_mutation_dict[lineage] = mutation_per_lineage
    print("fine request important mutation")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t1 = Timer(secs, get_all_important_mutation)
    t1.start()


all_protein_dict = {}


def get_all_protein():
    print("inizio request protein")
    to_send = {'gcm': {'taxon_name':["severe acute respiratory syndrome coronavirus 2"]}}

    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    headers = {'Content-type': 'application/json'}
    send = to_send
    json_data = json.dumps(send)
    conn.request('POST', '/virusurf_epitope/api/epitope/allProtein', json_data, headers)

    response = conn.getresponse()
    all_protein = response.read().decode()
    all_protein = json.loads(all_protein)
    all_protein_dict['all_protein'] = all_protein
    print("fine request protein")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t2 = Timer(secs, get_all_protein)
    t2.start()


all_lineage_dict = {}


def get_all_lineage():
    print("inizio request lineage")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allLineages')

    response = conn.getresponse()
    all_lin = response.read().decode()
    all_lin = json.loads(all_lin)
    all_lineage_dict['all_lineage'] = all_lin
    print("fine request lineage")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t3 = Timer(secs, get_all_lineage)
    t3.start()


all_geo_dict = {}


def get_all_geo():
    print("inizio request geo")
    conn = http.client.HTTPConnection('geco.deib.polimi.it')
    conn.request('GET', '/virusurf_epitope/api/epitope/allGeo')

    response = conn.getresponse()
    all_geo = response.read().decode()
    all_geo = json.loads(all_geo)
    all_geo_dict['all_geo'] = all_geo
    print("fine request geo")
    x = datetime.today()
    y = x.replace(day=x.day, hour=2, minute=0, second=0, microsecond=0) + timedelta(days=1)
    delta_t = y - x
    secs = delta_t.total_seconds()
    t4 = Timer(secs, get_all_geo)
    t4.start()


def prova_mongo_db():
    print("prova Mongo")
    # results = db.seq.aggregate([
    #     {
    #         "$group": {
    #             "fullname": {
    #                 "$covv_accession_id"
    #             }
    #         }
    #     }]
    # )
    # print("qui", results)
    # for i, x in enumerate(results):
    #     print("qui2", x)

    seq = db.seq

    pipeline = [
        {
            "$match": {
                'covv_collection_date': {
                    '$gte': "2019-01-01",
                    '$lte': "2021-07-31",
                    '$regex': "\d\d\d\d-\d\d-\d\d"
                },
                        'covv_location': {
                            '$regex': "Italy"
                         },
            },
        },
        {"$unwind": "$muts"},
        {"$group": {"_id": {'pr': "$muts.pr",
                            'orig': "$muts.orig",
                            'loc': "$muts.loc",
                            'alt': "$muts.alt",
                            }
            , "count": {"$sum": 1}}},
        #     { '$sort': { "_id.orig": -1 } }

    ]
    print("start")
    results = seq.aggregate(pipeline, )
    print("stop")
    for i, x in enumerate(results):
        if i < 1:
            print("qui", x)
            break
    print("fine prova Mongo2")


get_all_important_mutation()
get_all_geo()
get_all_protein()
get_all_lineage()
# prova_mongo_db()
